{"version":3,"sources":["node_modules/browser-pack/_prelude.js","lib/t.js","src/chart.js","src/donut.d3.js","src/sunburst.d3.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC9cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"donut.sunburst.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","// version 0.5.1 ([source](https://github.com/aaronj1335/t-js))\n//\n// t-js is freely distributable under the MIT license\n//\n// <a href=\"https://travis-ci.org/aaronj1335/t-js\" target=_blank>\n//   <img src=\"https://api.travis-ci.org/aaronj1335/t-js.png?branch=master\">\n// </a>\n//\n\n// overview\n// ========\n// t.js is a tree-traversal library.  its only assumption is that the trees it\n// traverses are made up of objects with 'children' arrays:\n//\n//      {\n//          children: [\n//              { },\n//              {\n//                  children: [\n//                      { },\n//                      { }\n//                  ]\n//              }\n//          ]\n//      }\n//\n//  the actual property name is configurable. the traversals are entirely\n//  non-recursive, including the post-order traversal and `map()` functions,\n//  and it works inside the browser or out.\n//\n// testing\n// -------\n// there's a bunch of tests in `test/test.js`. you can run them along with the\n// linter with:\n//\n//     $ npm install && npm test\n//\n// or view them on most any system with a modern browser by opening the\n// `index.html` file.\n//\n// documentation is generated with the `grunt docs` target.\n//\n// (function() {\n\n\n// usage\n// -----\n// the `t` interface is exported in either the browser or node.js. the library\n// can be installed from [npm](http://search.npmjs.org/#/t):\n//\n//     $ npm install t\n//\nvar _dfsPostOrder,\n    t = {},\n    root = this,\n    isArray = function(o) {\n        return Object.prototype.toString.call(o) === '[object Array]';\n    },\n    getChildrenName = function (config) {\n        return config.childrenName || 'children';\n    };\n\nif (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports)\n        exports = module.exports = t;\n    exports.t = t;\n} else {\n    root.t = t;\n}\n\n\n// available functions\n// ===================\n\n// t.bfs()\n// -------\n// perform a breadth-first search, executing the given callback at each node.\n//\n//      t.bfs(node, [config], function(node, par, ctrl) {\n//          /* ... */\n//      })\n//\n// - `node`:\n//      object where the search will start.  this could also be an array of\n//      objects\n// - `config`:\n//      you can define the name of the children property with\n//      `config.childrenName` (shoutout to @GianlucaGuarini)\n// - `callback` (last argument):\n//      function to be executed at each node.  the arguments are:\n//      - `node`: the current node\n//      - `par`: the current node's parent\n//      - `ctrl`: control object.  this doesn't currently do anything.\n//\n//  returns: the first `node` argument\n//\n\n\nt.bfs = function(node) {\n\n    var cur, ctrl, callback, i, length, par, children,\n        isConfigSet = arguments.length === 3,\n        config = isConfigSet ? arguments[1] : {},\n        queue = isArray(node)? node.slice(0) : [node],\n        parents = [undefined],\n        childrenName = getChildrenName(config);\n\n    if (node == null) return node;\n\n    if (arguments.length >= 3) {\n        config = arguments[1];\n        callback = arguments[2];\n    } else {\n        config = {};\n        callback = arguments[1];\n    }\n\n    while (queue.length) {\n        cur = queue.shift();\n        par = parents.shift();\n        ctrl = {}\n        callback.call(cur, cur, par, ctrl);\n\n        if ( ctrl.stop ) break;\n\n        children = cur[childrenName] || [];\n        for (i = 0, length = children.length; i < length; i++) {\n            queue.push(children[i]);\n            parents.push(cur);\n        }\n    }\n\n    return node;\n};\n\n// t.dfs()\n// -------\n// perform a depth-first search, executing the given callback at each node.\n//\n//      t.dfs(node, [config], function(node, par, ctrl) {\n//          /* ... */\n//      })\n//\n//  in the pre-order case, `dfs()` doesn't process child nodes until after the\n//  callback.  so if you need to traverse an unknown tree, say a directory\n//  structure, you can start with just the root, and add child nodes as you go\n//  by appending them to `this.children` in the callback function.\n//\n// - `node`:\n//      object where the search will start.  this could also be an array of\n//      objects\n// - `config`:\n//      if this is an object w/ the 'order' property set to 'post', a\n//      post-order traversal will be performed.  this is generally worse\n//      performance, but the `callback` has access to the return values of its\n//      child nodes. you can define the name of the children property with\n//      `config.childrenName`\n// - `callback` (last argument):\n//      function to be executed at each node.  the arguments are:\n//      - `node`: the current node\n//      - `par`: the current node's parent\n//      - `ctrl`: control object.  setting the `stop` property of this will end\n//      the search, setting the `cutoff` property of this will not visit any\n//      children of this node\n//      - `ret`: return values of child nodes.  this is only set if `dfs()` is\n//      called with the `order` property set to `post`.\n//\n//  returns: the first `node` argument\n//\nt.dfs = function(node) {\n    var cur, par, children, ctrl, i, ret,\n        isConfigSet = arguments.length === 3,\n        nodes = isArray(node)? node.slice(0).reverse() : [node],\n        config = isConfigSet ? arguments[1] : {},\n        callback = arguments[isConfigSet ? 2 : 1],\n        parents = [],\n        childrenName = getChildrenName(config);\n    if (typeof nodes[0] === 'undefined' && nodes.length === 1) return;\n\n    if (config.order === 'post') {\n        ret = _dfsPostOrder(nodes, config, callback);\n        return isArray(node)? ret : ret[0];\n    }\n\n\n    for (i = nodes.length-1; i >= 0; i--)\n        parents.push(undefined);\n\n    while (nodes.length > 0) {\n        cur = nodes.pop();\n        par = parents.pop();\n\n        ctrl = {};\n        callback.call(cur, cur, par, ctrl);\n\n        if (ctrl.stop) break;\n\n        children = (cur && cur[childrenName])? cur[childrenName] : [];\n\n        for (i = ctrl.cutoff? -1 : children.length-1; i >= 0; i--) {\n            nodes.push(children[i]);\n            parents.push(cur);\n        }\n    }\n\n    return node;\n};\n\n// t.map()\n// -------\n// given a tree, return a tree of the same structure made up of the objects\n// returned by the callback which is executed at each node.  think of the\n// `underscore`'s `_.map()` function, or python's `map()`\n//\n//      t.map(node, [config], function(node, par) {\n//          /* ... */\n//      })\n//\n// - `node`:\n//      object where the traversal will start.  this could also be an array of\n//      objects\n// - `config`:\n//      you can define the name of the children property with\n//      `config.childrenName`\n// - `callback` (last argument):\n//      function to be executed at each node.  this must return an object.  the\n//      `map` function takes care of setting children.  the arguments are:\n//      - `node`: the current node\n//      - `par`: the current node's parent. note that this is the parent from\n//      the new tree that's being created.\n//\n//  returns: a new tree, mapped by the callback function\n//\nt.map = function() {\n    var node = arguments[0],\n        isConfigSet = arguments.length === 3,\n        config = isConfigSet ? arguments[1] : {},\n        filter = config.filter,\n        nodeFactory = arguments[isConfigSet ? 2 : 1],\n        ret = isArray(node)? [] : undefined,\n        last = function(l) { return l[l.length-1]; },\n        parentStack = [],\n        childrenName = getChildrenName(config);\n\n    t.dfs(node, config, function(n, par, ctrl) {\n        var curParent = last(parentStack),\n            newNode = nodeFactory(n, curParent? curParent.ret : undefined);\n\n        if (filter && ! newNode) {\n            ctrl.cutoff = true;\n            if (curParent && n === last(curParent.n[childrenName])) {\n                parentStack.pop();\n                if (curParent.ret[childrenName] &&\n                        ! curParent.ret[childrenName].length)\n                    delete curParent.ret[childrenName];\n            }\n            return;\n        }\n\n        if (! par) {\n            if (isArray(node))\n                ret.push(newNode);\n            else\n                ret = newNode;\n\n        } else {\n            curParent.ret[childrenName].push(newNode);\n\n            if (n === last(curParent.n[childrenName])) {\n                parentStack.pop();\n                if (curParent.ret[childrenName] &&\n                        ! curParent.ret[childrenName].length)\n                    delete curParent.ret[childrenName];\n            }\n        }\n\n        if (n[childrenName] && n[childrenName].length) {\n            newNode[childrenName] = [];\n            parentStack.push({n: n, ret: newNode});\n        }\n    });\n\n    return ret;\n};\n\n// t.filter()\n// ----------\n// given a tree, return a tree of the same structure made up of the objects\n// returned by the callback which is executed at each node.  if, however, at a\n// given node the callback returns a falsy value, then the current node and all\n// of its descendents will be pruned from the output tree.\n//\n//      t.filter(node, [config], function(node, par) {\n//          /* ... */\n//      })\n//\n// - `node`:\n//      object where the traversal will start.  this could also be an array of\n//      objects\n// - `config`:\n//      you can define the name of the children property with\n//      `config.childrenName`\n// - `callback` (last argument):\n//      function to be executed at each node.  this must return an object or a\n//      falsy value if the output tree should be pruned from the current node\n//      down.  the `filter` function takes care of setting children.  the\n//      arguments are:\n//      - `node`: the current node\n//      - `par`: the current node's parent. note that this is the parent from\n//      the new tree that's being created.\n//\n// returns: a new tree, filtered by the callback function\n//\nt.filter = function(node) {\n    var isConfigSet = arguments.length === 3,\n        nodeFactory =  arguments[isConfigSet ? 2 : 1],\n        config = isConfigSet ? arguments[1] : {};\n    return t.map(node, {\n        filter: true,\n        childrenName: config.childrenName\n    }, nodeFactory);\n};\n\n// t.stroll()\n// ----------\n//\n// _a walk through the trees..._\n//\n// given two trees of similar structure, traverse both trees at the same time,\n// executing the given callback with the pair of corresponding nodes as\n// arguments.\n//\n//      t.stroll(tree1, tree2, [config], function(node1, node2) {\n//          /* ... */\n//      })\n//\n// - `tree1`:\n//      the first tree of the traversal\n// - `node2`:\n//      the second tree of the traversal\n// - `config`:\n//      you can define the name of the children property with\n//      `config.childrenName`\n// - `callback` (last argument):\n//      function to be executed at each node. the arguments are:\n//      - `node1`: the node from the first tree\n//      - `node2`: the node from the second tree\n//\nt.stroll = function(tree1, tree2) {\n    var i, node2,\n        isConfigSet = arguments.length === 4,\n        callback =  arguments[ isConfigSet ? 3 : 2],\n        config = isConfigSet ? arguments[2] : {},\n        childrenName = getChildrenName(config),\n        nodes2 = isArray(tree2)? tree2.slice(0).reverse() : [tree2],\n        len = function(a) { return typeof a === 'undefined'? 0 : a.length; };\n\n    t.dfs(tree1, config, function(node1, par, ctrl) {\n        node2 = nodes2.pop();\n\n        callback(node1, node2);\n\n        if (node1 && node2 &&\n                len(node1[childrenName]) === len(node2[childrenName]))\n            for (i = (node2[childrenName] || []).length-1; i >= 0; i--)\n                nodes2.push(node2[childrenName][i]);\n        else\n            ctrl.cutoff = true;\n\n    });\n};\n\n// t.find()\n// ----------\n//\n// given a tree and a truth test, return the first node that responds with a\n// truthy value\n//\n//      t.find(tree, [config], function(node, par) {\n//          /* ... */\n//      })\n//\n// - `tree`:\n//      the tree in which to find the node\n// - `config`:\n//      you can define the name of the children property with\n//      `config.childrenName`\n// - `callback` (last argument):\n//      function to be executed at each node. if this function returns a truthy\n//      value, the traversal will stop and `find` will return the current node.\n//      the arguments are:\n//      - `node`: the current node\n//      - `par`: the parent of the current node\n//\n// returns: the found node\n//\nt.find = function( tree ) {\n    var found,\n        isConfigSet = arguments.length === 3,\n        callback =  arguments[ isConfigSet ? 2 : 1],\n        config = isConfigSet ? arguments[1] : {};\n    t.dfs(tree, config, function(node, par, ctrl) {\n        if (callback.call(node, node, par)) {\n            ctrl.stop = true;\n            found = this;\n        }\n    });\n\n    return found;\n};\n\n// _dfsPostOrder()\n// -----------------\n//\n// this is a module-private function used by `dfs()`\n_dfsPostOrder = function(nodes, config, callback) {\n    var cur, par, ctrl, node,\n        last = function(l) { return l[l.length-1]; },\n        ret = [],\n        stack = [{\n            node: nodes.pop(),\n            index: 0,\n            ret: []\n        }],\n        childrenName = getChildrenName(config);\n\n    while (stack.length) {\n        cur = last(stack);\n        node = cur.node;\n\n        if (node[childrenName] && node[childrenName].length) {\n            if (cur.index < node[childrenName].length) {\n                stack.push({\n                    node: node[childrenName][cur.index++],\n                    index: 0,\n                    ret: []\n                });\n                continue;\n            }\n        }\n\n        ctrl = {};\n        par = stack[stack.length-2];\n        if (par) {\n            par.ret.push(callback.call(node, node, par.node, ctrl, cur.ret));\n            stack.pop();\n        } else {\n            ret.push(callback.call(node, node, undefined, ctrl, cur.ret));\n            stack.pop();\n            if (nodes.length)\n                stack.push({\n                    node: nodes.pop(),\n                    index: 0,\n                    ret: []\n                });\n        }\n    }\n\n    return ret;\n};\n\n// }());\nmodule.exports = t;","/*  Chase Miller (2015-2016) */\n\n// Grab an existing iobio namespace object, or create a blank object\n// if it doesn't exist\nvar iobio = global.iobio || {};\nglobal.iobio = iobio;\n\n// Defaults\nvar binnerData = [],\n    binnerClassifiedData = [],\n    sunburstD3 = require('./sunburst.d3.js'),\n    donutD3 = require('./donut.d3.js'),\n    t = require('../lib/t.js');\n\n// Add custom click to fix issue w/ D3\n$.fn.d3Click = function () {\n  this.each(function (i, e) {\n    var evt = document.createEvent(\"MouseEvents\");\n    evt.initMouseEvent(\"click\", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n\n    e.dispatchEvent(evt);\n  });\n};\n\nglobal.iobio.donutSunburst = function(div, pieChartCallback ) {\n  this.cmd;\n  this.pieChartCallback = pieChartCallback;\n  // create binner html\n  $(div).append(\"<div id='big-binner' class='results'><div id='b'></><div style='clear:both'></div></div>\")\n  var $bigBinner = $('#big-binner');\n  this.bigBinnerElem = $bigBinner[0];\n  var h = $bigBinner.height();\n  var w = h + 120;\n  $bigBinner.css('width', w + 'px')\n  $bigBinner.css('height', h + 'px')\n  $bigBinner.css('left', 'calc(50% - ' + w/2 + 'px)');\n  $('#big-binner #b').append(\"<svg id='big-binner-binner' viewbox='0 0 \" + w + \" \" + h + \"'  preserveAspectRatio='xMidYMid' style='margin-top:20px' ></svg>\");\n  this.bigBinnerBinnerElem = $('#big-binner-binner')[0];\n\n  // create sunburst html\n  $(div).append(\"<div id='main-viz' class='results'><div id='selected-name'>All</div><div id='viz'></div><div id='reads-viewed'><h4 id='total-reads'>Total <span id='bin'></span> Reads Classified: <span class='iobio-txt-color'></span></h4><div style='clear:both'></div></div></div>\")\n  var $mainViz = $('#main-viz');\n  this.mainViz = $mainViz[0];\n\n  // create error message\n  $(div).append(\"<div id='no-results' style='display:none'><div>Oops there was an error</div><div>Please try again and make sure your file or url is valid</div></div>\")\n\n  this.sunburstElem = $('#viz')[0];\n  var w = h + 12;\n  $mainViz.css('width', w + 'px')\n  $mainViz.css('height', h + 'px')\n  $mainViz.css('left', 'calc(50% - ' + w/2 + 'px)');\n  $(this.sunburstElem).append(\"<svg id='sunburst-chart' viewbox='0 0 \" + w + \" \" + h + \"'  preserveAspectRatio='xMidYMid' style='margin-top:20px' ></svg>\");\n  $(this.sunburstElem).append(\"<div id='bar-chart'></div>\");\n  $('#big-binner').css('visibility', 'hidden');\n  $('#main-viz').css('visibility', 'hidden');\n  // set attributes\n  // create svg\n}\n\n\nglobal.iobio.donutSunburst.prototype.goObj = function(data) {\n    this.go(data, { data:true });\n}\n\n\nglobal.iobio.donutSunburst.prototype.go = function(data, options) {\n  options = options || {};\n  this.ignoreData = false;\n  var self = this;\n  var sunburstElem = this.sunburstElem;\n  var bigBinnerElem = this.bigBinnerElem;\n\n  $('#big-binner').css('visibility', 'hidden');\n  $('#main-viz').css('visibility', 'hidden');\n  self.mode = 'binner';\n\n  // create charts\n  var commaFormatter = d3.format(\",0f\");\n  var radiusBig = $('#big-binner-binner').height()/2;\n  var binnerColor = d3.scale.ordinal()\n        .domain(['bacterial', 'fungal', 'human', 'viral', 'unknown', 'ambiguous', 'phage', 'phix'])\n        .range(['#e31b00','#0081f3', '#003F78', '#83338F', 'rgb(120,120,120)', '#A7AAB3', '#008C26', '#06ac61'])\n\n  self.bigBinnerChart = donutD3()\n        .radius(radiusBig-40)\n        .thickness(radiusBig)\n        .klass(\"binnerArc\")\n        .click(function(d) { self.toSunburst(d.name) })\n        .color(function(d) {   return binnerColor(d.data.name); })\n        .tooltip(function(d, total) {\n          var percent = parseInt(d.value / total * 1000) / 10;\n          return d.data.name + ' binned: ' + commaFormatter(d.value) + ' (' + percent + '%)';\n        });\n  self.bigBinnerClassifiedChart = donutD3()\n        .radius(radiusBig-20)\n        .thickness(20)\n        .klass(\"binnerClassArc\")\n        .click(function(d) { self.toSunburst(d.name) })\n        .color(function(d) {   if(d.data.type=='binner') {return 'white'} else {return binnerColor(d.data.name);} })\n        .tooltip(function(d) { return d.data.name.split('-')[0] + ' classified: ' + commaFormatter(d.value) });\n  self.binnerPie = d3.layout.pie().sort(function(a,b) { return d3.ascending(a.name,b.name); }).value(function(d) { return d.count});\n\n  var h = $(sunburstElem).find('svg').height();\n  var w  = $(sunburstElem).find('svg').width();\n  self.sunburstChart = sunburstD3()\n      .width( w )\n      .height( h )\n      .clickBefore( function(currRoot) {\n        self.updateBreadcrumbs(currRoot);\n        $('#selected-name').html( currRoot.name.split(':')[1] == 'root' ? currRoot.children[0].name : currRoot.name );\n      });\n\n  self.options = options;\n  var commaFormat = d3.format(\"0,000\");\n  displayData(data);\n\n\n  function displayData (data) {\n    $('#sunburst-spinner').css('display', 'none')\n    // transform binner data\n    binnerData = [];\n    binnerClassifiedData = [];\n    var total = 0;\n    if (data.binnerResult['phage'] == undefined) data.binnerResult['phage'] = 0;\n    Object.keys(data.binnerResult).forEach(function(key){\n\n      if (key == 'unclassified') {\n          binnerData.push( {name:'unknown', count:data.binnerResult[key]} );\n      } else {\n        binnerData.push( {name:key, count:data.binnerResult[key]} );\n      }\n      // gather data for classified portion of binner pie chart\n      if (data.classifierResult[key] != undefined) {\n        var cCount = data.classifierResult[key].count || 0;\n        binnerClassifiedData.push( {name: key, count: cCount, type:'classified'});\n        binnerClassifiedData.push( {name:key+'-binner', count:data.binnerResult[key]-cCount, type:'binner'} );\n      } else {\n        if (key == 'unclassified')\n          binnerClassifiedData.push( {name:'unknown-binner', count:data.binnerResult[key], type:'binner'} );\n        else\n          binnerClassifiedData.push( {name:key+'-binner', count:data.binnerResult[key], type:'binner'} );\n      }\n      total += data.binnerResult[key]\n    })\n\n\n    // update metrics\n    $('#reads-sampled .metric').html(numberFormatter(total));\n\n    if (total == 0 || (total ==1 && data.binnerResult.unclassified)){\n      total = 0;\n      if (self.options && self.options.errorCallback) self.options.errorCallback(\"NO RESULTS\");\n      $('#iobio-viz #no-results').css('display', 'block');\n      $('#iobio-viz').css('display', 'block');\n      return;\n    }\n    else {$('#no-results').css('display', 'none')}\n\n    // transform classifier data\n    var classifierRoot = { 'name' : 'root', 'id' : 'root', 'count' : 0,  'children' : [] };\n    Object.keys(data.classifierResult).forEach(function(key) {\n\n      if (data.classifierResult[key].children != undefined) {\n        if (data.classifierResult[key].children[0].children == undefined) {\n          var root = data.classifierResult[key];\n          classifierRoot.children.push( root );\n        }\n        else {\n          var root = data.classifierResult[key].children[0];\n          if (root.name == 'no rank:root' && root.children[0].name == 'no rank:cellular organisms' && root.count > root.children[0].count ) {\n            root.count = root.children[0].count;\n            // root = root.children[0];\n          }\n          classifierRoot.children.push( root );\n        }\n      }\n      var count = data.classifierResult[key].count || 0;\n      classifierRoot['count'] += count;\n    })\n\n    var rows = ['human', 'viral', 'bacterial', 'fungal', 'ambiguous', 'unclassified', 'phage', 'phix'];\n    rows.forEach(function(key){\n      var cCount = data.classifierResult[key] ? data.classifierResult[key].count : undefined;\n      classifierRoot.children.forEach(function(cat) {\n        if (cat.bin == key) // see if root for bin has been changed and if so take the changed root\n          cCount = cat.count;\n      })\n      if (cCount == undefined) cCount = '';\n      else cCount = ' (' + commaFormat(cCount) + ')'\n      $('.' + key + '-binned-reads').html( commaFormat(data.binnerResult[key]) + cCount )\n    });\n\n    // update classified total\n    $('#reads-classified .metric').html(numberFormatter(classifierRoot['count']));\n    $('#percent-reads-classified .metric').html(d3.format('%')(classifierRoot['count']/total));\n\n    self.rootData = JSON.parse(JSON.stringify(classifierRoot));\n\n    // update correct chart\n    if ( self.mode == 'binner') {\n      $('#big-binner').css('visibility', 'visible');\n      $('#main-viz').css('visibility', 'hidden');\n      $('#sunburst-filters input').css('visibility', 'visible');\n      self.drawBigBinnerChart(binnerData, binnerClassifiedData, {chartElem: self.bigBinnerBinnerElem})\n    } else {\n      $('#big-binner').css('visibility', 'hidden');\n      $('#main-viz').css('visibility', 'visible');\n      $('#sunburst-filters input').css('visibility', 'hidden');\n      var currTopRoot = d3.select('#main-viz path').data()[0];\n      var currH = treeToHash(currTopRoot, 'id');\n      var newDataCurrRoot;\n      t.bfs(self.rootData, [], function(node, par, ctrl) {\n           if (node.id == currTopRoot.id && node.bin == currTopRoot.bin) {\n             newDataCurrRoot = node;\n             t.bfs(newDataCurrRoot, [], function(n, p, c) {\n               if(currH[n.id] != undefined) {\n                 n.x0 = currH[n.id].x0;\n                 n.dx0 = currH[n.id].dx0;\n               }\n             });\n             ctrl['stop'] = true;\n           }\n       })\n      var fCount = $('#min-read-count-slider').val();\n      if (fCount > 1)\n        self.filterCount(fCount, newDataCurrRoot);\n      else {\n        var selection = d3.select(self.sunburstElem).select('svg').datum( newDataCurrRoot );\n        self.sunburstChart(selection, {transitionDuration:200});\n      }\n      // update total reads in this bin\n      var binCount = self.getBinRoot(newDataCurrRoot.bin);\n      if (binCount == undefined) binCount = '';\n      else binCount = binCount.count\n      $('#total-reads .iobio-txt-color').html( binCount )\n    }\n\n  }\n}\n\n\n\nglobal.iobio.donutSunburst.prototype.drawBigBinnerChart = function(bData, classifiedData, options) {\n  var self = this;\n\n  $('#sunburst-top-controls').css('visibility', 'hidden');\n\n  // select only the checked bins to draw\n  options = options || {};\n  var chartElem = options.chartElem || '#big-binner-binner';\n  bData = bData || binnerData;\n  classifiedData = classifiedData || binnerClassifiedData;\n  var binnerDatatoDraw = [];\n  $.extend(true, binnerDatatoDraw, bData)\n  var classifiedDatatoDraw = [];\n  $.extend(true, classifiedDatatoDraw, classifiedData)\n\n\n  var notCheckedBins = $('#sunburst-filters input:not(:checked)').toArray();\n  notCheckedBins.forEach(function(d) {\n    var bin = d.getAttribute('data-bin');\n    binnerDatatoDraw.forEach(function(b) { if (b.name == bin) b.count = 0; })\n    classifiedDatatoDraw.forEach(function(c) { if (c.name.split('-')[0] == bin) c.count = 0; })\n  })\n\n  var bData = self.binnerPie(binnerDatatoDraw);\n  var cData = self.binnerPie(classifiedDatatoDraw);\n\n  var arcBig = d3.select(chartElem).selectAll(\".binnerArc\")\n      .data(bData, function(d) { return d.data.name; });\n  self.bigBinnerChart(arcBig, options);\n\n  var arcClassifiedBig = d3.select(chartElem).selectAll(\".binnerClassArc\")\n      .data(cData, function(d) { return d.data.name; });\n  options.events = false;\n  self.bigBinnerClassifiedChart(arcClassifiedBig, options);\n}\n\nglobal.iobio.donutSunburst.prototype.resetCheckButtons = function() {\n  $('#sunburst-filters .btn-group input').prop('checked', true);\n  $('#sunburst-filters button').prop('disabled', false);\n}\n\nglobal.iobio.donutSunburst.prototype.resetCatButtons = function() {\n  $('#sunburst-filters .btn-group').removeClass('disable-filter');\n}\n\nglobal.iobio.donutSunburst.prototype.toSunburst = function(bin) {\n  var self = this;\n  var binNode = self.getBinRoot(bin);\n  if (binNode == undefined)  {\n    $('#no-classified-reads-modal #bin-category').html(bin);\n    $('#no-classified-reads-modal').modal('show');\n    this.resetCatButtons();\n    return;\n  }\n\n  self.mode = 'sunburst';\n  $('#min-abundance').css('visibility', 'visible');\n  var selection = d3.select(\"#viz svg\").datum(binNode);\n\n  self.sunburstChart.clear();\n  self.sunburstChart(selection);\n\n  this.initBreadcrumbs(binNode.children[0]);\n  // disable all buttons except this bin\n  $('#sunburst-filters .btn-group:not(:has(.btn-'+bin+'-filter))').addClass('disable-filter');\n  // hide all check boxes\n  $('#sunburst-filters input').css('visibility', 'hidden');\n\n  // drill into binner chart\n  var data = [{\"name\":\"viral\",\"count\":0},{\"name\":\"unknown\",\"count\":0},{\"name\":\"fungal\",\"count\":0},{\"name\":\"bacterial\",\"count\":0},{\"name\":\"human\",\"count\":0},{\"name\":\"ambiguous\",\"count\":0},{\"name\":\"phage\",\"count\":0}]\n  data.forEach(function(d) { if (d.name==bin) d.count = 1; })\n// ------ Console Log Data here -------- //\n  this.drawBigBinnerChart(data, data, {events: true})\n\n  // do this horrible event b\\c i don't know how to tell when binner transition is over\n  $('#selected-name').html( binNode.children[0].name );\n  $('#big-binner-binner').on(\"binnerTransitionOver\", function() {\n    $('#big-binner').css('visibility', 'hidden');\n\n    // show hide panels\n    $('#main-viz').css('visibility', 'visible');\n    $('#sunburst-top-controls').css('visibility', 'visible');\n    $('.composition').css('display', 'none');\n    $('#' + bin + '-composition').css('display', 'block');\n    $('#total-reads #bin').html(bin.charAt(0).toUpperCase() + bin.slice(1))\n    var binCount = self.getBinRoot(bin);\n    if (binCount == undefined) binCount = '';\n    else binCount = binCount.count;\n    $('#total-reads .iobio-txt-color').html( binCount );\n  });\n\n}\n\nglobal.iobio.donutSunburst.prototype.initBreadcrumbs = function(node) {\n  var self = this;\n  if ($('#sunburst-breadcrumbs ul').length == 0) $('#sunburst-breadcrumbs').append('<ul></ul>');\n  $('#sunburst-breadcrumbs ul').html('');\n  $('#sunburst-breadcrumbs ul').append('<li> <span data-node=\"root\" class=\"sunburst-breadcrumb\">Pie Chart</span></li>')\n  $('#sunburst-breadcrumbs ul').append('<li><div class=\"extra-border\"/><span class=\"sunburst-breadcrumb\">' + node.name.split(':')[1] + '</span></li>')\n  $('#sunburst-breadcrumbs .sunburst-breadcrumb').on('click', function() {\n    var node = this.getAttribute('data-node');\n    self.selectCategory(node);\n  })\n}\n\nglobal.iobio.donutSunburst.prototype.updateBreadcrumbs = function(node) {\n  var self = this;\n  var maxBreadcrumbs = 3;\n  $('#sunburst-breadcrumbs ul').html('');\n  if (self.mode == 'binner') return;\n  node = node || getCurrRoot();\n  if (node == undefined) return;\n  if(node.name.split(':')[1] == 'root') node = node.children[0];\n\n  var breadcrumbList = [];\n  while(node != undefined ) {\n    breadcrumbList.unshift(node);\n    node = node.parent;\n  }\n\n  var start = parseInt((breadcrumbList.length-1) / maxBreadcrumbs) * maxBreadcrumbs ;\n  for (var i=0; i< breadcrumbList.length; i++ ) {\n    var n = breadcrumbList[i];\n    var nid;\n    var nname;\n    var borderStyle='';\n\n    if (n.name.split(':')[1] == 'root') {\n      nid = 'root';\n      nname = 'Pie Chart';\n    } else {\n      nid = n.id;\n      nname = n.name.split(':')[1];\n    }\n\n    $('#sunburst-breadcrumbs ul').append('<li><span class=\"sunburst-breadcrumb\" data-node=\"' + nid + '\">' + nname + '</span></li><li><span class=\"sunburst-breadcrumb-navigator\">...</span></li>');\n\n    var ulH = $('#sunburst-breadcrumbs ul').height();\n    var liH = $('#sunburst-breadcrumbs ul li').height();\n\n    $('#sunburst-breadcrumbs ul li').last().remove();\n\n    if ( ulH > liH ) {\n      var elemLi = $('#sunburst-breadcrumbs ul li').last()\n      elemLi.prevAll().css('display', 'none');\n      elemLi.before('<li><span class=\"sunburst-breadcrumb-navigator\" data-node=\"' + nid + '\" data-direction=\"back\">...</span></li>')\n    }\n  }\n\n  // add border\n  $('#sunburst-breadcrumbs ul li span').last().before('<div class=\"extra-border\"/>');\n\n  $('#sunburst-breadcrumbs .sunburst-breadcrumb').on('click', function() {\n    var node = this.getAttribute('data-node');\n    self.selectCategory(node);\n  })\n\n  $('#sunburst-breadcrumbs .sunburst-breadcrumb-navigator').on('click', function() {\n    var direction = this.getAttribute('data-direction');\n    var $elem = $(this).parent();\n    if (direction == 'back') {\n      $elem.prevAll().each(function(i, d) {\n        d.style.display = 'inline-block';\n        if (d.children[0].innerHTML == '...') return false;\n      })\n      $elem.nextAll().css('display', 'none');\n      this.setAttribute('data-direction', 'forward');\n    } else {\n      $elem.nextAll().each(function(i, d) {\n        d.style.display = 'inline-block';\n        if (d.children[0].innerHTML == '...') return false;\n      })\n      $elem.prevAll().css('display', 'none');\n      this.setAttribute('data-direction', 'back');\n    }\n  })\n}\n\nglobal.iobio.donutSunburst.prototype.selectCategory = function(path) {\n  var self = this;\n  if (typeof path == 'string' || path instanceof String) {\n    var pathId = path;\n    path = document.getElementById(path);\n  }\n  else\n    var pathId = path.id;\n  if (pathId == 'root') {\n    if (self.pieChartCallback) self.pieChartCallback();\n    self.mode = 'binner';\n    $('#main-viz').css('visibility', 'hidden');\n    $('#big-binner').css('visibility', 'visible');\n    $('#sunburst-filters .btn-group:has(input:checked)').removeClass('disable-filter')\n    $('#sunburst-filters input').css('visibility', 'visible');\n    self.updateBreadcrumbs()\n    self.drawBigBinnerChart(null, null, {events: false})\n  } else\n    $(path).d3Click();\n}\n\nglobal.iobio.donutSunburst.prototype.filterCount = function(val, root) {\n  var self = this;\n  var r = filterTree(val, function(node, val) {\n    return (node.name == 'root' || node.count  >= parseInt(val))\n  }, root);\n\n  var selection = d3.select(\"#viz svg\").datum(r);\n  self.sunburstChart(selection, {pixelFilter:true});\n}\n\nglobal.iobio.donutSunburst.prototype.getBinRoot = function(bin) {\n  var root,\n      self = this;\n\n  t.bfs(self.rootData, [], function(node, par, ctrl) {\n       if (node.bin == bin) {\n         root = node;\n         ctrl['stop'] = true;\n       }\n   })\n  return root;\n}\n\n\nfunction updateSliderActive() {\n  if (atRoot()) {\n    $('#min-read-count-slider').css('visibility', 'visible');\n    $('#min-abundance').css('visibility', 'visible');\n  }\n  else {\n    $('#min-read-count-slider').css('visibility', 'hidden');\n    $('#min-abundance').css('visibility', 'hidden');\n  }\n}\n\nfunction filterTree(val, expression, root) {\n  root = root || getAbsoluteRoot();\n  var displayCount = 0;\n\n  t.dfs(root, [], function(node, par, ctrl) {\n    if (node._count != undefined) {\n      node.count = node._count;\n      node._count = undefined;\n    }\n    if (!expression(node, val)) {\n      t.dfs(node, [], function(n, par, ctrl) {\n        if(n.count != undefined && n.count != 0) {\n          n._count = n.count;\n          n.count = 0;\n        }\n      });\n      ctrl['cutoff'] = true;\n    } else {\n      displayCount += node.count\n    }\n    // updateReadsViewed(displayCount);\n })\n\n  return root;\n}\n\nfunction numberFormatter (d) {\n  var m = d/100000;\n  var str = m.toString()[1];\n  var dot = parseInt(str);\n  if ((d / 1000000) >= 1)\n    d = parseInt(d / 1000000) + \".\" +dot+ \"M\";\n  else if ((d / 1000) >= 1)\n    d = Math.round(d / 1000) + \"K\";\n  return d;\n}\n","var donutD3 = function() {\n   var radius = 90,\n       thickness = 7,\n       labelr = radius + 30,\n       klass = 'arc',\n       total = 0;\n\n   var svg;\n   var arc = d3.svg.arc();\n   var color = d3.scale.category20c();\n   var options = { text:true }\n   var click = function() { return; };\n   var tooltip = function() { return; };\n\n   var formatter = d3.format(\",.1f\");\n   var commaFormatter = d3.format(\",0f\");\n\n   function my(selection, opts) {\n      options = $.extend(options, opts);\n      labelr = radius + 30;\n      arc = d3.svg.arc()\n      .outerRadius(radius)\n      .innerRadius(radius - thickness);\n\n      svg = selection[0].parentNode;\n      var bbox = svg.getBoundingClientRect();\n\n      var g = selection.enter().append(\"g\")\n         .attr(\"class\", klass)\n         .attr(\"transform\", \"translate(\"+ bbox.width/2 + \",\" + bbox.height/2 + \")\");\n\n      // if ( g.data()[0] != undefined )\n      //    var total = g.data()[0].data + g.data()[1].data\n      // else\n      //    var total = selection.data()[0].data + selection.data()[1].data\n\n      var path = g.append(\"path\")\n         .attr(\"d\", arc )\n         .style('fill', function(d,i) { return color(d) })\n         .on('click', function(d){\n            click(d.data);\n         })\n          .each(function(d) { this._current = d; });\n\n      total = 0;\n      selection.data().forEach(function(d) { total += d.value; })\n      if (tooltip) {\n        path.on('mouseover', null);\n        path\n          .on(\"mouseover\", function(d,i) {\n               iobioSunburstTooltipDiv.transition()\n                  .duration(200)\n                  .style(\"opacity\", .9);\n               iobioSunburstTooltipDiv.html(tooltip(d, total))\n            .style(\"left\", (d3.event.pageX) + \"px\")\n            .style(\"text-align\", 'left')\n            .style(\"top\", (d3.event.pageY - 24) + \"px\");\n            })\n            .on(\"mouseout\", function(d) {\n               iobioSunburstTooltipDiv.transition()\n                  .duration(500)\n                  .style(\"opacity\", 0);\n            })\n      }\n\n      selection.exit().transition().remove();\n\n      if (options.text) {\n         g.append(\"text\")\n           .attr(\"transform\", function(d) {\n                var c = arc.centroid(d),\n                    x = c[0],\n                    y = c[1],\n                    // pythagorean theorem for hypotenuse\n                    h = Math.sqrt(x*x + y*y);\n                return \"translate(\" + (x/h * labelr) +  ',' +\n                   (y/h * labelr) +  \")\";\n            })\n            .attr(\"dy\", \".35em\")\n            .attr(\"text-anchor\", function(d) {\n                // are we past the center?\n                return (d.endAngle + d.startAngle)/2  > Math.PI ?\n                    \"end\" : \"start\";\n            })\n            // .attr(\"dy\", \"1.9em\")\n            // .style(\"text-anchor\", \"middle\")\n            .text(function(d,i) {\n              var a = d.endAngle - d.startAngle\n              if (a > 0.08)\n                return d.data.name[0].toUpperCase() + d.data.name.slice(1,d.data.name.length);\n            });\n      }\n\n      selection.select('text').transition()\n        .duration(200)\n        .attr(\"transform\", function(d) {\n            var c = arc.centroid(d),\n                x = c[0],\n                y = c[1],\n                // pythagorean theorem for hypotenuse\n                h = Math.sqrt(x*x + y*y);\n            return \"translate(\" + (x/h * labelr) +  ',' +\n               (y/h * labelr) +  \")\";\n        })\n        .attr(\"text-anchor\", function(d) {\n            // are we past the center?\n            return (d.endAngle + d.startAngle)/2 > Math.PI ?\n                \"end\" : \"start\";\n        })\n        .text(function(d,i) {\n           var a = d.endAngle - d.startAngle\n           if (a <= 0.08)\n             return '';\n           else\n             return d.data.name[0].toUpperCase() + d.data.name.slice(1,d.data.name.length);\n        });\n\n      selection.select(\"path\").transition()\n        .duration(400)\n        .attrTween('d', arcTween)\n        .call(endall, function() {\n          if (options.events) {\n            $(svg).trigger({\n              type: \"binnerTransitionOver\",\n            });\n          }\n        });\n        // .attr(\"d\", arc);\n\n      function arcTween(a) {\n        var i = d3.interpolate(this._current, a);\n        this._current = i(0);\n        return function(t) {\n          return arc(i(t));\n        };\n      }\n\n      function endall(transition, callback) {\n        var n = 0;\n        transition\n            .each(function() { ++n; })\n            .each(\"end\", function() { if (!--n) callback.apply(this, arguments); });\n      }\n\n        // Computes the angle of an arc, converting from radians to degrees.\n      function angle(d) {\n        var a = (d.startAngle + d.endAngle) * 90 / Math.PI;\n        // if (a > 270 && a < 360) return 0;\n        // if (a > 270) return 0;\n        // if (a > 0 && a < 180) return 0;\n        // if ( (a > 0 && a < 70) || (a >110 && a < 250) || (a > 290) ) return 0;\n        if ((Math.abs(a) >20 && Math.abs(a) < 160) || (a > 200 && a < 340)) return 0;\n        a -= 90;\n        return a > 90 ? -25 : -25;\n      }\n\n      return this;\n   }\n\n\n   my.radius = function(value) {\n      if (!arguments.length) return radius;\n      radius = value;\n      return my;\n   }\n\n   my.thickness = function(value) {\n      if (!arguments.length) return thickness;\n      thickness = value;\n      return my;\n   }\n\n   my.color = function(value) {\n      if (!arguments.length) return color;\n      color = value;\n      return my;\n   }\n\n  my.click = function(_) {\n    if (!arguments.length) return click;\n    click = _;\n    return my;\n  }\n\n  my.tooltip = function(_) {\n    if (!arguments.length) return tooltip;\n    tooltip = _;\n    return my;\n  }\n\n   my.klass = function(value) {\n      if (!arguments.length) return klass;\n      klass = value;\n      return my;\n   };\n\n   return my;\n}\n\nmodule.exports = donutD3;","/*\n * Sunburst visualization\n *\n * Created by Chase Miller 2015\n */\n\n  var sunburstD3 = function() {\n    window.iobioSunburstTooltipDiv = d3.select(\"body\").append(\"div\").attr(\"class\", \"tooltip\").style(\"opacity\", 1);\n\n    var margin = {top: 25, right: 10, bottom: 25, left: 10},\n        width = 200,\n        height = 200,\n        defaultOptions = {klass:'', 'text' : true, 'click': true, 'mouseover': true, 'idPrefix': '', transitionDuration:750, pixelFilter:true},\n        color = d3.scale.category20c(),\n        textColor = 'white',\n        absoluteTotal = 0,\n        relativeTotal = 0,\n        radius = Math.min(width - margin.left - margin.right, height - margin.top - margin.bottom) / 2,\n        x = d3.scale.linear().range([0, 2 * Math.PI]),\n        y = d3.scale.sqrt().range([0, radius]),\n        arc = d3.svg.arc()\n          .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })\n          .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })\n          .innerRadius(function(d) { return Math.max(0, y(d.y)); })\n          .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); }),\n        normX = d3.scale.linear();\n\n    var node;\n    var partition = d3.layout.cumulativePartition().sort(null).value(function(d) { return d.count; });\n\n    var click = function() { return; };\n    var clickBefore = function() { return; };\n\n    var me = this;\n\n    function chart(selection, opts) {\n      var self  = this;\n      // merge options and defaults\n      var options = extend({}, defaultOptions, opts);\n\n      // recalc radius & y scale & arc\n      var newRadius = Math.min(width - margin.left - margin.right, height - margin.top - margin.bottom) / 2;;\n      if (radius != newRadius ) {\n        radius = newRadius;\n        y.range([0, radius]);\n        arc = d3.svg.arc()\n            .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x))); })\n            .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); })\n            .innerRadius(function(d) { return Math.max(0, y(d.y)); })\n            .outerRadius(function(d) { return Math.max(0, y(d.y + d.dy)); });\n      }\n\n      // process selection\n      selection.each(function(data) {\n        self.data = data;\n         if (!data)\n          return;\n        // set svg element\n        var svg = d3.select(this);\n        svg\n          .on('mouseover', function() { d3.selectAll('.rotateControl').style(\"visibility\",\"visible\") })\n          .on('mouseout', function() { d3.selectAll('.rotateControl').style(\"visibility\",\"hidden\") });\n\n        // Select the g element, if it exists.\n        var g = svg.selectAll(\"g\").data([0]);\n\n        // Otherwise, create the skeletal chart.\n        var gEnter = g.enter().append(\"g\")\n            .attr('class', 'gEnter')\n            .attr(\"transform\", \"rotate(0,\"+width/2+',' + (height / 2) + \") translate(\" + width / 2 + \",\" + (height / 2 ) + \")\")\n            // .attr(\"transform\", \"rotate(0,\"+width/2+',' + (height / 2 + 10) + \") translate(\" + width / 2 + \",\" + (height / 2 + 10) + \")\")\n\n        absoluteTotal = data.count;\n        relativeTotal = 0;\n\n        // generate sunburst coordinates\n        var nodes = partition.nodes(data);\n\n        // set or reset head node\n        if (node == undefined || node.bin != data.bin) {\n          node = data;\n        }\n\n        // set domain and ranges\n        if (node) {\n          x.domain([node.x, node.x + node.dx]);\n          y.domain([node.y, 1]);\n          y.range([node.y ? 20 : 0, radius]);\n        }\n\n        var colors = {\n          'viral' : { range:['#3D0385', '#FFB7DB'], interpolate:'interpolateHcl'},\n          'bacterial' : { range:['#970015', '#FFC886'], interpolate:'interpolateHsl'},\n          'fungal' : { range:['#3B00AD', '#B3FFAB'], interpolate:'interpolateHcl'},\n          'phage' : { range:['#03553C', '#DCFF00'], interpolate:'interpolateHcl'}\n        }\n\n        var lastChild = nodes[0].children[0].children[nodes[0].children[0].children.length-1];\n        // set color space\n        var bin = nodes[0].bin;\n        color = d3.scale.linear()\n          .domain([0.075,lastChild.x + lastChild.dx + 0.75])\n          .range( colors[bin].range )\n          .interpolate(d3[ colors[bin].interpolate ])\n          .clamp(true);\n\n        textColor = d3.hcl(color(0.7)).brighter(1);\n\n        // enter\n        if (options.pixelFilter)\n          var path = g.selectAll(\".path\")\n                  .data(nodes.filter(function(d){\n\n                    if (options.filter && !options.filter(d)) return false;\n\n                    var sa = Math.max(0, Math.min(2 * Math.PI, x(d.x)));\n                    var ea = Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx)));\n                    var angle = ea - sa;\n                    var r = Math.max(0, y(d.y + d.dy));\n                    var s = angle*r;\n                    if (node && node.id == d.id || r == 0) return true;\n                    return s >= 1;\n                  }),\n                  function(d) { return d.id; })\n        else\n          var path = g.selectAll(\".path\")\n                  .data(nodes, function(d) { return d.id; })\n\n        // exit\n        path.exit().remove();\n\n        //  update any paths that stuck around (e.g. viruses is in both phage and viral sunbursts)\n        g.selectAll('.path').select('path')\n          .style(\"fill\", determineColor);\n\n        // enter\n        var gPath = path.enter().append('g')\n                .attr('class', 'path');\n\n        gPath.append(\"path\")\n              .attr(\"d\", arc)\n              .attr('id', function(d) { return options.idPrefix + d.id; })\n              .style(\"fill\", determineColor)\n              .on(\"click\", clickHandler)\n              .on(\"mouseover\", function(d,i) {\n                if(i == 0 || !options.mouseover) return;\n                  iobioSunburstTooltipDiv.style('display', 'block');\n                  iobioSunburstTooltipDiv.transition()\n                     .duration(200)\n                     .style(\"opacity\", .9);\n                  var category = d.name.split(':')[0];\n                  var percent = \"<div>Absolute Percent:\" + parseInt(d.count / absoluteTotal * 1000) / 10 + \"%</div>\";\n                  if (relativeTotal >0) percent+= \"<div>Relative Percent:\" + parseInt(d.count / relativeTotal * 1000) / 10 + \"%</div>\";\n                  if (category == 'no rank')\n                    iobioSunburstTooltipDiv.html(d.name.split(':')[1] + ' - ' + d.count + ' read(s)' + percent )\n                  else if (d.name.split(':')[0] == 'species')\n                    iobioSunburstTooltipDiv.html('species:' + d.parent.name.split(':')[1] + '.' + d.name.split(':')[1] + ' - ' + d.count + ' read(s)' + percent )\n                  else\n                    iobioSunburstTooltipDiv.html(d.name + ' - ' + d.count + ' read(s)' + percent )\n               .style(\"left\", (d3.event.pageX + 4) + \"px\")\n               .style(\"text-align\", 'left')\n               .style(\"top\", (d3.event.pageY - 62) + \"px\");\n               })\n               .on(\"mouseout\", function(d) {\n                  iobioSunburstTooltipDiv.transition()\n                     .duration(500)\n                     .style(\"opacity\", 0);\n                  iobioSunburstTooltipDiv.transition()\n                    .delay(500)\n                    .duration(0)\n                    .style('display', 'none');\n               }).each(stash);\n\n        if (options.text) {\n          var text = gPath.append('text')\n                .attr('x', function(d) { return 0; })\n                .attr('dy', function(d) {return (y(d.y + d.dy) - y(d.y))/2;})\n                .attr('dx', function(d) {\n                  var sa = x(d.x);\n                  var ea = x(d.x + d.dx);\n                  var angle = ea - sa;\n                  var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n                  return (angle*r)/2 ;\n                })\n                .style('fill', determineLetterColor)\n                .style('letter-spacing', determineLetterSpacing);\n\n          text.append(\"textPath\")\n              .attr('id', function(d) { return d.id + '-text'})\n              .attr('class', 'textpath')\n              .attr(\"xlink:href\",function(d) { return location.pathname + '#' + d.id; })\n              .attr('alignment-baseline', \"middle\")\n              .attr('text-anchor', \"middle\")\n              .style('height', '10px');\n\n        }\n\n        // Add rotate control\n        gEnter.append('image')\n          .attr('x', radius + 5)\n          .attr('y', -10 )\n          .attr('xlink:href', 'assets/images/rotate.png')\n          .attr('width', 20 )\n          .attr('height', 20)\n          .attr('class', 'rotateControl')\n          .call(d3.behavior.drag()\n              .on(\"drag\", function (d) {\n                var exy = [d3.event.x, d3.event.y],\n                  dxy = [0, 0],\n                  dist = distanceBetweenPoints(exy, dxy),\n                  currentAngle = parseInt(g.attr('transform').split('rotate(')[1].split(',')[0]),\n                  angle = angleBetweenPoints(dxy, exy);\n                  var degreeAngle = (toDegrees(angle)) + currentAngle;\n                  // g.attr(\"transform\", \"rotate(\" + degreeAngle + \",\"+width/2+',' + (height / 2 + 10) + \") translate(\" + width / 2 + \",\" + (height / 2 + 10) + \")\");\n                  g.attr(\"transform\", \"rotate(\" + degreeAngle + \",\"+width/2+',' + (height / 2 ) + \") translate(\" + width / 2 + \",\" + (height / 2 ) + \")\");\n              })\n\n          );\n\n          gEnter.append('line')\n            .attr('x1', 0)\n            .attr('y1', 0)\n            .attr('x2', radius + 5)\n            .attr('y1', 0)\n            .attr('class', 'rotateControl')\n            .style('stroke', '#2d8fc1')\n\n        // update\n        g.selectAll('.path').select('path').transition()\n          .duration(options.transitionDuration)\n          .style(\"fill\", determineColor)\n          .attrTween(\"d\", arcTweenData);\n\n        g.selectAll('.path').select('text').transition()\n            .duration(options.transitionDuration)\n            .attr('x', function(d) { return 0; })\n            .attr('dy', function(d) {return (y(d.y + d.dy) - y(d.y))/2;})\n            .attr('dx', function(d) {\n              var sa = x(d.x);\n              var ea = x(d.x + d.dx);\n              var angle = ea - sa;\n              var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n              return (angle*r)/2 ;\n            })\n            .style('fill', determineLetterColor)\n            .style('letter-spacing', determineLetterSpacing)\n\n        g.selectAll('.path').select('.textpath').transition()\n          .duration(options.transitionDuration)\n          .text(function(d,i) {\n            // get arc length, s\n            var sa = x(d.x);\n            var ea = x(d.x + d.dx);\n            var angle = ea - sa;\n            var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n            var s = angle*r-2;\n            if (s < 18) return;\n\n            var pathId = d.id.split('-text')[0];\n            var name = d.name.split(':')[1] || '';\n            this.textContent = name;\n\n            var ls = determineLetterSpacing(d);\n\n            var fontsize = 15;\n            for (var k=fontsize; k >=9; k--) {\n              this.style.fontSize = k;\n              if (this.getComputedTextLength() + (name.length-1) * ls <= s)\n                return name;\n            }\n            return;\n        })\n\n\n\n        d3.select(self.frameElement).style(\"height\", height + \"px\");\n\n      }); // end selection.each\n\n      function determineLetterColor(d,i) {\n        // get color of arc\n        var c = determineColor(d,i);\n        // conver to hsl\n        var hcl = d3.hcl(c);\n        var l = parseInt(hcl.l)\n        if (l > 87 && c.toString() != 'white') return textColor;\n        else return \"white\";\n      }\n\n      function determineColor(d,i) {\n        if(i == 0) return 'white';\n        if (node && node.parent && node.parent.id == d.id ) return color.range()[0];\n\n        var dMid = normX(d.x)+ (normX(d.x+d.dx)-normX(d.x))/2 ;\n        var depth = node ? d.depth - node.depth : d.depth\n        if (depth <= 3 ) brighter = 0;\n        else brighter = depth / 6;\n        var c = color(dMid + d.y);\n        return d3.hcl(c).brighter(brighter);\n\n      }\n\n      // click hanlder\n      function clickHandler(clickData) {\n        var data = clickData;\n        while(data.parent) { data = data.parent };\n\n        relativeTotal = node.count;\n        // if (node.name == 'root:root') return; // ignore root clicks\n        if (clickData.parent && clickData.parent.name.split(':')[1] == 'root') {\n          clickData = clickData.parent;\n        }\n        node = clickData;\n        if (options.click) {\n          clickBefore(node);\n\n          // if(y(d.y) <= 20) {return} // do nothing for center rings\n          // selection.selectAll('text').remove();\n          var endX = d3.scale.linear().range([0, 2 * Math.PI]).domain([clickData.x, clickData.x+clickData.dx])\n          var endY = d3.scale.linear().range([clickData.y ? 20 : 0, radius]).domain([clickData.y, 1])\n\n          normX = d3.scale.linear().domain([clickData.x, clickData.x + clickData.dx]).range([0.075,0.58]);\n          var lastChildMax = normX(clickData.x) + normX(clickData.dx)/2 + clickData.y,\n              n,\n              stack = [clickData];\n\n          // get last child max accurately\n          while( (n=stack.pop()) != null ) {\n            var nMax = (normX(n.x) + (normX(n.x+n.dx)-normX(n.x))/2 + n.y);\n            if ( nMax > lastChildMax  ) lastChildMax = nMax;\n\n            if (n.children) stack = stack.concat( n.children )\n          }\n\n\n          color.domain([normX(clickData.x) + clickData.y, lastChildMax]);\n\n          // selection.selectAll('path')\n          if (options.pixelFilter)\n            var path = selection.select('g').selectAll(\".path\")\n                  .data(partition.nodes(data).filter( function(n) {\n                    // return ((endX(n.x+n.dx) - endX(n.x)) > 0.003);\n                    var sa = Math.max(0, Math.min(2 * Math.PI, endX(n.x)));\n                    var ea = Math.max(0, Math.min(2 * Math.PI, endX(n.x + n.dx)));\n                    var angle = ea - sa;\n                    var r = Math.max(0, endY(n.y + n.dy));\n                    var s = angle*r;\n                    return (s >= 1 || (n.y <= clickData.y));\n                  }),\n                    function(d) { return d.id; })\n          else\n            var path = selection.select('g').selectAll(\".path\")\n                    .data(partition.nodes(data), function(d) { return d.id; })\n\n          path.exit().remove();\n\n          var gPath = path.enter().append('g')\n                  .attr('class', 'path');\n\n          gPath.append(\"path\")\n                .attr(\"d\", arc)\n                .attr('id', function(d) { return options.idPrefix + d.id; })\n                .style(\"fill\", determineColor)\n                .on(\"click\", clickHandler)\n                .on(\"mouseover\", function(d,i) {\n                  if(i == 0 || !options.mouseover) return;\n                    iobioSunburstTooltipDiv.transition()\n                       .duration(200)\n                       .style(\"opacity\", .9);\n                    var category = d.name.split(':')[0];\n                    if (category == 'no rank')\n                      iobioSunburstTooltipDiv.html(d.name.split(':')[1] + ' - ' + d.count)\n                    else\n                      iobioSunburstTooltipDiv.html(d.name + ' - ' + d.count)\n                 .style(\"left\", (d3.event.pageX) + \"px\")\n                 .style(\"text-align\", 'left')\n                 .style(\"top\", (d3.event.pageY - 24) + \"px\");\n                 })\n                 .on(\"mouseout\", function(d) {\n                    iobioSunburstTooltipDiv.transition()\n                       .duration(500)\n                       .style(\"opacity\", 0);\n                 }).each(stash);\n\n            if (options.text) {\n              var text = gPath.append('text')\n                    .attr('x', function(d) { return 0; })\n                    .attr('dy', function(d) {return (y(d.y + d.dy) - y(d.y))/2;})\n                    .attr('dx', function(d) {\n                      var sa = x(d.x);\n                      var ea = x(d.x + d.dx);\n                      var angle = ea - sa;\n                      var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n                      return (angle*r)/2 ;\n                    })\n                    .style('fill', determineLetterColor)\n                    .style('letter-spacing', determineLetterSpacing);\n\n              text.append(\"textPath\")\n                  .attr('id', function(d) { return d.id + '-text'})\n                  .attr('class', 'textpath')\n                  .attr(\"xlink:href\",function(d) { return location.pathname + '#' + d.id; })\n                  .attr('alignment-baseline', \"middle\")\n                  .attr('text-anchor', \"middle\")\n                  .style('height', '10px');\n            }\n\n            selection.selectAll('.path').select('path').transition()\n              .duration(750)\n              .attrTween(\"d\", arcTween(clickData))\n              .style(\"fill\", determineColor)\n              .call(endall, function() {\n                click(node);\n                selection.selectAll('text')\n                  .attr('x', function(d) { return 0; })\n                  .attr('dy', function(d) {return (y(d.y + d.dy) - y(d.y))/2;})\n                  .attr('dx', function(d) {\n                    var sa = x(d.x);\n                    var ea = x(d.x + d.dx);\n                    var angle = ea - sa;\n                    var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n                    return (angle*r)/2;\n                  })\n                  .style('fill', determineLetterColor)\n                  .style('letter-spacing', determineLetterSpacing)\n                selection.selectAll('.textpath')\n                  .text(function(d,i) {\n                    if (d.x < x.domain()[0] || d.x >= x.domain()[1])\n                      return;\n\n                    // get arc length, s\n                    var sa = x(d.x);\n                    var ea = x(d.x + d.dx);\n                    var angle = ea - sa;\n                    var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n                    var s = angle*r;\n                    if (s < 18) return;\n                    var ls = determineLetterSpacing(d);\n\n                    var pathId = d.id.split('-text')[0];\n                    var name = d.name.split(':')[1] || '';\n                    this.textContent = name;\n                    var fontsize = 15;\n                    for (var k=fontsize; k >=9; k--) {\n                      this.style.fontSize = k;\n                      if (this.getComputedTextLength() + (name.length-1) * ls <= s)\n                        return name;\n                    }\n                    return;\n                  })\n              });\n\n        }\n      }\n      // When zooming: interpolate the scales.\n      function arcTween(d) {\n        var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]),\n            yd = d3.interpolate(y.domain(), [d.y, 1]),\n            yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]);\n        return function(d, i) {\n          return  i\n              ? function(t) { return arc(d); }\n              : function(t) {\n                x.domain(xd(t));\n                y.domain(yd(t)).range(yr(t));\n                return arc(d);};\n        };\n      }\n\n      // When switching data: interpolate the arcs in data space.\n      function arcTweenData(a, i) {\n        var currRoot = node;\n        if (a.x0 == undefined || a.dx0 == undefined) {\n          a.x0 = a.x + a.dx/2;\n          a.dx0 = 0;\n        }\n        var oi = d3.interpolate({x: a.x0, dx: a.dx0}, a);\n        function tween(t) {\n          var b = oi(t);\n          a.x0 = b.x;\n          a.dx0 = b.dx;\n          return arc(b);\n        }\n        if (i == 0) {\n         // If we are on the first arc, adjust the x domain to match the root node\n         // at the current zoom level. (We only need to do this once.)\n          var xd = d3.interpolate(x.domain(), [currRoot.x, currRoot.x + currRoot.dx]),\n              yd = d3.interpolate(y.domain(), [currRoot.y, 1]),\n              yr = d3.interpolate(y.range(), [currRoot.y ? 20 : 0, radius]);\n          return function(t) {\n            x.domain(xd(t));\n            y.domain(yd(t)).range(yr(t));\n            return tween(t);\n          };\n        } else {\n          return tween;\n        }\n      }\n\n\n      function getNodeById(nodeId) {\n        var root = this.data;\n        if (nodeId == undefined) return root;\n        var nodes = [root];\n        var n;\n        while(n = nodes.shift()) {\n          if (n.id == nodeId) return n;\n          if (n.children)\n            nodes = nodes.concat( n.children );\n        }\n      }\n\n\n      function determineLetterSpacing(d) {\n        var r = y(d.y) + (y(d.y + d.dy) - y(d.y))/2;\n        if (r > 130) return 0;\n        return (130-r) / 16;\n      }\n\n      // Setup for switching data: stash the old values for transition.\n      function stash(d) {\n        d.x0 = d.x;\n        d.dx0 = d.dx;\n      }\n\n      // end of transition solution\n      function endall(transition, callback) {\n        var n = 0;\n        transition\n            .each(function() { ++n; })\n            .each(\"end\", function() { if (!--n) callback.apply(this, arguments); });\n      }\n\n      function angleBetweenPoints(p1, p2) {\n        return Math.atan2(p2[1] - p1[1], p2[0] - p1[0] );\n      }\n\n      function distanceBetweenPoints(p1, p2) {\n        return Math.sqrt( Math.pow( p2[1] - p1[1], 2 ) + Math.pow( p2[0] - p1[0], 2 ) );\n      }\n\n      function toDegrees(rad) {\n        return rad * (180/Math.PI);\n      }\n\n      function extend(){\n          for(var i=1; i<arguments.length; i++)\n              for(var key in arguments[i])\n                  if(arguments[i].hasOwnProperty(key))\n                      arguments[0][key] = arguments[i][key];\n          return arguments[0];\n      }\n\n      // creates a tree with less nodes. replaces all the nodes past a certain depth with\n      // a single gray node per level. Allows huge trees to be visualized\n      function downSampleTree(root, depth) {\n        var t = require('../lib/t.js')\n        t.dfs(root, [], function(node, par, ctrl) {\n          if (node.depth > depth) {\n            var sumCount = 0;\n            var childrenList = undefined;\n            if(node.children) {\n              node.children.forEach(function(child){\n                sumCount += child.count;\n                if (child.children) {\n                  childrenList = childrenList || [];\n                  child.children.forEach(function(c){ childrenList.push(c); })\n                }\n              })\n              node.children = [ {\n                count : sumCount,\n                children : childrenList,\n                id : node.children[0].id,\n                depth : node.children[0].depth,\n                name : 'many',\n                bin : node.children[0].bin,\n                parent : node,\n                x : node.children[0].x,\n                y : node.children[0].y,\n                dx : node.children[0].dx,\n                dy : node.children[0].dy,\n                value : sumCount\n              }]\n            }\n          }\n       })\n      }\n    } // end chart function\n\n\n    chart.clear = function() {\n      node = undefined;\n    }\n\n    chart.margin = function(_) {\n      if (!arguments.length) return margin;\n      margin = _;\n      return chart;\n    };\n\n    chart.width = function(_) {\n      if (!arguments.length) return width;\n      width = _;\n      return chart;\n    };\n\n    chart.height = function(_) {\n      if (!arguments.length) return height;\n      height = _;\n      return chart;\n    };\n\n    chart.x = function(_) {\n      if (!arguments.length) return x;\n      x = _;\n      return chart;\n    };\n\n    chart.y = function(_) {\n      if (!arguments.length) return y;\n      y = _;\n      return chart;\n    };\n\n    chart.color = function(_) {\n      if (!arguments.length) return color;\n      color = _;\n      return chart;\n    };\n\n    chart.click = function(_) {\n      if (!arguments.length) return click;\n      click = _;\n      return chart;\n    }\n    chart.clickBefore = function(_) {\n      if (!arguments.length) return clickBefore;\n      clickBefore = _;\n      return chart;\n    }\n\n    return chart;\n  }\n\n   d3.layout.cumulativeHierarchy = function() {\n      var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\n      function hierarchy(root) {\n        var stack = [ root ], nodes = [], node;\n        root.depth = 0;\n        while ((node = stack.pop()) != null) {\n          nodes.push(node);\n          if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\n            var n, childs, child;\n            while (--n >= 0) {\n              stack.push(child = childs[n]);\n              child.parent = node;\n              child.depth = node.depth + 1;\n            }\n            if (value) node.value = +value.call(hierarchy, node, node.depth);\n            node.children = childs;\n          } else {\n            if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\n            delete node.children;\n          }\n        }\n        d3_layout_hierarchyVisitAfter(root, function(node) {\n          var childs, parent;\n          if (sort && (childs = node.children)) childs.sort(sort);\n          // if (value && (parent = node.parent))  parent.value += node.value;\n        });\n        return nodes;\n      }\n      hierarchy.sort = function(x) {\n        if (!arguments.length) return sort;\n        sort = x;\n        return hierarchy;\n      };\n      hierarchy.children = function(x) {\n        if (!arguments.length) return children;\n        children = x;\n        return hierarchy;\n      };\n      hierarchy.value = function(x) {\n        if (!arguments.length) return value;\n        value = x;\n        return hierarchy;\n      };\n      hierarchy.revalue = function(root) {\n        if (value) {\n          d3_layout_hierarchyVisitBefore(root, function(node) {\n            if (node.children) node.value = 0;\n          });\n          d3_layout_hierarchyVisitAfter(root, function(node) {\n            var parent;\n            if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\n            if (parent = node.parent) parent.value += node.value;\n          });\n        }\n        return root;\n      };\n      return hierarchy;\n    };\n    function d3_layout_hierarchyRebind(object, hierarchy) {\n      d3.rebind(object, hierarchy, \"sort\", \"children\", \"value\");\n      object.nodes = object;\n      object.links = d3_layout_hierarchyLinks;\n      return object;\n    }\n    function d3_layout_hierarchyVisitBefore(node, callback) {\n      var nodes = [ node ];\n      while ((node = nodes.pop()) != null) {\n        callback(node);\n        if ((children = node.children) && (n = children.length)) {\n          var n, children;\n          while (--n >= 0) nodes.push(children[n]);\n        }\n      }\n    }\n    function d3_layout_hierarchyVisitAfter(node, callback) {\n      var nodes = [ node ], nodes2 = [];\n      while ((node = nodes.pop()) != null) {\n        nodes2.push(node);\n        if ((children = node.children) && (n = children.length)) {\n          var i = -1, n, children;\n          while (++i < n) nodes.push(children[i]);\n        }\n      }\n      while ((node = nodes2.pop()) != null) {\n        callback(node);\n      }\n    }\n    function d3_layout_hierarchyChildren(d) {\n      return d.children;\n    }\n    function d3_layout_hierarchyValue(d) {\n      return d.value;\n    }\n    function d3_layout_hierarchySort(a, b) {\n      return b.value - a.value;\n    }\n    function d3_layout_hierarchyLinks(nodes) {\n      return d3.merge(nodes.map(function(parent) {\n        return (parent.children || []).map(function(child) {\n          return {\n            source: parent,\n            target: child\n          };\n        });\n      }));\n    }\n\n\n  /*\n   * Cumulative partition add on for d3.js\n   * same as paritiion function but sums all the children nodes as part\n   * of the total value for each arc\n   * Created by Chase Miller 2015\n   */\n  d3.layout.cumulativePartition = function() {\n    var hierarchy = d3.layout.cumulativeHierarchy(), size = [ 1, 1 ];\n    function position(node, x, dx, dy) {\n      var children = node.children;\n      node.x = x;\n      node.y = node.depth * dy;\n      node.dx = dx;\n      node.dy = dy;\n      if (children && (n = children.length)) {\n        var i = -1, n, c, d;\n        dx = node.value ? dx / node.value : 0;\n        while (++i < n) {\n          position(c = children[i], x, d = c.value * dx, dy);\n          x += d;\n        }\n      }\n    }\n    function depth(node) {\n      var children = node.children, d = 0;\n      if (children && (n = children.length)) {\n        var i = -1, n;\n        while (++i < n) d = Math.max(d, depth(children[i]));\n      }\n      return 1 + d;\n    }\n    function partition(d, i) {\n      var nodes = hierarchy.call(this, d, i);\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\n      return nodes;\n    }\n    partition.size = function(x) {\n      if (!arguments.length) return size;\n      size = x;\n      return partition;\n    };\n    return d3_layout_hierarchyRebind(partition, hierarchy);\n  };\n\n  module.exports = sunburstD3;"]}